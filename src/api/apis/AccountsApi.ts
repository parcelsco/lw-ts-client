/* tslint:disable */
/* eslint-disable */
/**
 * Lemonway DirectKit API 2.0
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AccountBalanceOutput,
  AccountBlockedInput,
  AccountBlockedOutput,
  AccountDetailsBatchInput,
  AccountDetailsBatchOutput,
  AccountDetailsOutput,
  AccountDocumentsOutput,
  AccountKycStatusOutput,
  AddUltimateBeneficialOwnerInput,
  AddUltimateBeneficialOwnerOutput,
  BalanceHistoryOutput,
  EnrolmentInitInput,
  EnrolmentInitOutput,
  GetUltimateBeneficialOwnerOutput,
  KycStatusOutput,
  RegisterIndividualAccountInput,
  RegisterIndividualAccountOutput,
  RegisterLegalAccountInput,
  RegisterLegalAccountOutput,
  SignDocumentInitInput,
  SignDocumentInitOutput,
  UpdateAccountStatusInput,
  UpdateAccountStatusOutput,
  UpdateIndividualAccountDetailsInput,
  UpdateIndividualAccountDetailsOutput,
  UpdateLegalAccountDetailsInput,
  UpdateLegalAccountDetailsOutput,
  UpdateUltimateBeneficialOwnerInput,
  UpdateUltimateBeneficialOwnerOutput,
  UploadDocumentInput,
  UploadDocumentOutput,
} from '../models';
import {
    AccountBalanceOutputFromJSON,
    AccountBalanceOutputToJSON,
    AccountBlockedInputFromJSON,
    AccountBlockedInputToJSON,
    AccountBlockedOutputFromJSON,
    AccountBlockedOutputToJSON,
    AccountDetailsBatchInputFromJSON,
    AccountDetailsBatchInputToJSON,
    AccountDetailsBatchOutputFromJSON,
    AccountDetailsBatchOutputToJSON,
    AccountDetailsOutputFromJSON,
    AccountDetailsOutputToJSON,
    AccountDocumentsOutputFromJSON,
    AccountDocumentsOutputToJSON,
    AccountKycStatusOutputFromJSON,
    AccountKycStatusOutputToJSON,
    AddUltimateBeneficialOwnerInputFromJSON,
    AddUltimateBeneficialOwnerInputToJSON,
    AddUltimateBeneficialOwnerOutputFromJSON,
    AddUltimateBeneficialOwnerOutputToJSON,
    BalanceHistoryOutputFromJSON,
    BalanceHistoryOutputToJSON,
    EnrolmentInitInputFromJSON,
    EnrolmentInitInputToJSON,
    EnrolmentInitOutputFromJSON,
    EnrolmentInitOutputToJSON,
    GetUltimateBeneficialOwnerOutputFromJSON,
    GetUltimateBeneficialOwnerOutputToJSON,
    KycStatusOutputFromJSON,
    KycStatusOutputToJSON,
    RegisterIndividualAccountInputFromJSON,
    RegisterIndividualAccountInputToJSON,
    RegisterIndividualAccountOutputFromJSON,
    RegisterIndividualAccountOutputToJSON,
    RegisterLegalAccountInputFromJSON,
    RegisterLegalAccountInputToJSON,
    RegisterLegalAccountOutputFromJSON,
    RegisterLegalAccountOutputToJSON,
    SignDocumentInitInputFromJSON,
    SignDocumentInitInputToJSON,
    SignDocumentInitOutputFromJSON,
    SignDocumentInitOutputToJSON,
    UpdateAccountStatusInputFromJSON,
    UpdateAccountStatusInputToJSON,
    UpdateAccountStatusOutputFromJSON,
    UpdateAccountStatusOutputToJSON,
    UpdateIndividualAccountDetailsInputFromJSON,
    UpdateIndividualAccountDetailsInputToJSON,
    UpdateIndividualAccountDetailsOutputFromJSON,
    UpdateIndividualAccountDetailsOutputToJSON,
    UpdateLegalAccountDetailsInputFromJSON,
    UpdateLegalAccountDetailsInputToJSON,
    UpdateLegalAccountDetailsOutputFromJSON,
    UpdateLegalAccountDetailsOutputToJSON,
    UpdateUltimateBeneficialOwnerInputFromJSON,
    UpdateUltimateBeneficialOwnerInputToJSON,
    UpdateUltimateBeneficialOwnerOutputFromJSON,
    UpdateUltimateBeneficialOwnerOutputToJSON,
    UploadDocumentInputFromJSON,
    UploadDocumentInputToJSON,
    UploadDocumentOutputFromJSON,
    UploadDocumentOutputToJSON,
} from '../models';

export interface AccountsAccountSingleGetRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsAddUltimateBeneficialOwnerRequest {
    accountId: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: AddUltimateBeneficialOwnerInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsBalancesGetRequest {
    authorization: string;
    pSUIPAddress: string;
    updateDate?: string;
    internalAccountIdStart?: number;
    internalAccountIdEnd?: number;
    page?: number;
    limit?: number;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsBalancesHistoryGetRequest {
    accountId: string;
    authorization: string;
    pSUIPAddress: string;
    atDate?: string;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsBlockedPutRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: AccountBlockedInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsDocumentGetRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsDocumentsSignInitPostRequest {
    accountid: string;
    documentid: number;
    authorization: string;
    pSUIPAddress: string;
    parameters: SignDocumentInitInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsDocumentsUploadPostRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: UploadDocumentInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsEnrolmentInitRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: EnrolmentInitInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsGetUltimateBeneficialOwnerRequest {
    accountId: string;
    authorization: string;
    pSUIPAddress: string;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsIndividualPostRequest {
    authorization: string;
    pSUIPAddress: string;
    parameters: RegisterIndividualAccountInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsIndividualPutRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: UpdateIndividualAccountDetailsInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsKycStatusGetRequest {
    updateDate: string;
    authorization: string;
    pSUIPAddress: string;
    page?: number;
    limit?: number;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsKycstatusPutRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: UpdateAccountStatusInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsLegalPostRequest {
    authorization: string;
    pSUIPAddress: string;
    parameters: RegisterLegalAccountInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsLegalSinglePutRequest {
    accountid: string;
    authorization: string;
    pSUIPAddress: string;
    parameters: UpdateLegalAccountDetailsInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsRetrievePostRequest {
    authorization: string;
    pSUIPAddress: string;
    parameters: AccountDetailsBatchInput;
    page?: number;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsTransactionsGetRequest {
    accountId: string;
    authorization: string;
    pSUIPAddress: string;
    startDate?: string;
    endDate?: string;
    executionDateStart?: string;
    executionDateEnd?: string;
    page?: number;
    limit?: number;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

export interface AccountsUpdateUltimateBeneficialOwnerRequest {
    accountId: string;
    ultimateBeneficialOwnerId: number;
    authorization: string;
    pSUIPAddress: string;
    parameters: UpdateUltimateBeneficialOwnerInput;
    pSUAcceptLanguage?: string;
    pSUUserAgent?: string;
}

/**
 * 
 */
export class AccountsApi extends runtime.BaseAPI {

    /**
     * This method enables your system to get detailed payment account information including: payment account balance, account type, if the account is blocked, and account email address.<br />               Fill at least one search field
     * Get Detailed Payment Account Data
     */
    async accountsAccountSingleGetRaw(requestParameters: AccountsAccountSingleGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountDetailsOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsAccountSingleGet.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsAccountSingleGet.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsAccountSingleGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountid}`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountDetailsOutputFromJSON(jsonValue));
    }

    /**
     * This method enables your system to get detailed payment account information including: payment account balance, account type, if the account is blocked, and account email address.<br />               Fill at least one search field
     * Get Detailed Payment Account Data
     */
    async accountsAccountSingleGet(requestParameters: AccountsAccountSingleGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountDetailsOutput> {
        const response = await this.accountsAccountSingleGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The method enables you to link an Ultimate Beneficial Owner to a legal payment account.  To be validated all Legal accounts need to provide their Ultimate Beneficial Owner information.  ```  An Ultimate Beneficial Owner is a natural person that owns directly or indirectly (i.e. through another entity)   more than 25% of the shares/stock or voting rights of the legal entity, or a person having significant control over it   through other means. Any company established in EEA or EU is obliged to obtain and maintain this information with the competent   central register (as per article 30 of Directive 2015/843/EU).   Similar requirements may also exist in other countries.  In order to comply with AML-CTF legal provisions, payment institutions are required   to identify the beneficial owner(s) of a legal entity(i.e.a company or an organisation).  ```  If the Legal Representative is also an Ultimate Beneficial Owner,  you can specify this information when creating or updating a legal account.
     * Create an Ultimate Beneficial Owner
     */
    async accountsAddUltimateBeneficialOwnerRaw(requestParameters: AccountsAddUltimateBeneficialOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AddUltimateBeneficialOwnerOutput>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling accountsAddUltimateBeneficialOwner.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsAddUltimateBeneficialOwner.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsAddUltimateBeneficialOwner.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsAddUltimateBeneficialOwner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountId}/ultimateBeneficialOwner`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddUltimateBeneficialOwnerInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AddUltimateBeneficialOwnerOutputFromJSON(jsonValue));
    }

    /**
     * The method enables you to link an Ultimate Beneficial Owner to a legal payment account.  To be validated all Legal accounts need to provide their Ultimate Beneficial Owner information.  ```  An Ultimate Beneficial Owner is a natural person that owns directly or indirectly (i.e. through another entity)   more than 25% of the shares/stock or voting rights of the legal entity, or a person having significant control over it   through other means. Any company established in EEA or EU is obliged to obtain and maintain this information with the competent   central register (as per article 30 of Directive 2015/843/EU).   Similar requirements may also exist in other countries.  In order to comply with AML-CTF legal provisions, payment institutions are required   to identify the beneficial owner(s) of a legal entity(i.e.a company or an organisation).  ```  If the Legal Representative is also an Ultimate Beneficial Owner,  you can specify this information when creating or updating a legal account.
     * Create an Ultimate Beneficial Owner
     */
    async accountsAddUltimateBeneficialOwner(requestParameters: AccountsAddUltimateBeneficialOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AddUltimateBeneficialOwnerOutput> {
        const response = await this.accountsAddUltimateBeneficialOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use the <b>GetBalances</b> method to get all payment accounts where the balance has changed since the input date,               or all the balances of payment accounts with internal ID between payment accountIdStart and payment accountIdEnd.
     * Get all Payment Account Balances
     */
    async accountsBalancesGetRaw(requestParameters: AccountsBalancesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountBalanceOutput>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsBalancesGet.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsBalancesGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateDate !== undefined) {
            queryParameters['updateDate'] = requestParameters.updateDate;
        }

        if (requestParameters.internalAccountIdStart !== undefined) {
            queryParameters['internalAccountIdStart'] = requestParameters.internalAccountIdStart;
        }

        if (requestParameters.internalAccountIdEnd !== undefined) {
            queryParameters['internalAccountIdEnd'] = requestParameters.internalAccountIdEnd;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/balances`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountBalanceOutputFromJSON(jsonValue));
    }

    /**
     * Use the <b>GetBalances</b> method to get all payment accounts where the balance has changed since the input date,               or all the balances of payment accounts with internal ID between payment accountIdStart and payment accountIdEnd.
     * Get all Payment Account Balances
     */
    async accountsBalancesGet(requestParameters: AccountsBalancesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountBalanceOutput> {
        const response = await this.accountsBalancesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Payment Account Balance History
     */
    async accountsBalancesHistoryGetRaw(requestParameters: AccountsBalancesHistoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BalanceHistoryOutput>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling accountsBalancesHistoryGet.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsBalancesHistoryGet.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsBalancesHistoryGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.atDate !== undefined) {
            queryParameters['atDate'] = requestParameters.atDate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountId}/balances/history`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BalanceHistoryOutputFromJSON(jsonValue));
    }

    /**
     * Get Payment Account Balance History
     */
    async accountsBalancesHistoryGet(requestParameters: AccountsBalancesHistoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BalanceHistoryOutput> {
        const response = await this.accountsBalancesHistoryGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Block or Unblock an Account
     */
    async accountsBlockedPutRaw(requestParameters: AccountsBlockedPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountBlockedOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsBlockedPut.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsBlockedPut.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsBlockedPut.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsBlockedPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountid}/blocked`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AccountBlockedInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountBlockedOutputFromJSON(jsonValue));
    }

    /**
     * Block or Unblock an Account
     */
    async accountsBlockedPut(requestParameters: AccountsBlockedPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountBlockedOutput> {
        const response = await this.accountsBlockedPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Documents Associated with a Payment Account
     */
    async accountsDocumentGetRaw(requestParameters: AccountsDocumentGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountDocumentsOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsDocumentGet.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsDocumentGet.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsDocumentGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountid}/documents`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountDocumentsOutputFromJSON(jsonValue));
    }

    /**
     * Get Documents Associated with a Payment Account
     */
    async accountsDocumentGet(requestParameters: AccountsDocumentGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountDocumentsOutput> {
        const response = await this.accountsDocumentGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This functionality allows you to generate an electronic signature. For now, only SDD mandates can be signed with this method.<br /><br />   Requirement:  <ul><li>A Mandate needs to be registered with RegisterSddMandate</li></ul>  Three steps to follow for this method:  <ul><li>A call to SignDocumentInit of DirectKit to make the signature request and get a token</li><li>A redirection from your website to the WebKit, with the token in GET parameter (see Finalize document signature)</li><li>A return page where your user will be redirected after the signature</li></ul>
     * Generate an Electronic Signature of a Document
     */
    async accountsDocumentsSignInitPostRaw(requestParameters: AccountsDocumentsSignInitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SignDocumentInitOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsDocumentsSignInitPost.');
        }

        if (requestParameters.documentid === null || requestParameters.documentid === undefined) {
            throw new runtime.RequiredError('documentid','Required parameter requestParameters.documentid was null or undefined when calling accountsDocumentsSignInitPost.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsDocumentsSignInitPost.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsDocumentsSignInitPost.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsDocumentsSignInitPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountid}/documents/{documentid}/signinit`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))).replace(`{${"documentid"}}`, encodeURIComponent(String(requestParameters.documentid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SignDocumentInitInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SignDocumentInitOutputFromJSON(jsonValue));
    }

    /**
     * This functionality allows you to generate an electronic signature. For now, only SDD mandates can be signed with this method.<br /><br />   Requirement:  <ul><li>A Mandate needs to be registered with RegisterSddMandate</li></ul>  Three steps to follow for this method:  <ul><li>A call to SignDocumentInit of DirectKit to make the signature request and get a token</li><li>A redirection from your website to the WebKit, with the token in GET parameter (see Finalize document signature)</li><li>A return page where your user will be redirected after the signature</li></ul>
     * Generate an Electronic Signature of a Document
     */
    async accountsDocumentsSignInitPost(requestParameters: AccountsDocumentsSignInitPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SignDocumentInitOutput> {
        const response = await this.accountsDocumentsSignInitPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload documents to a payment account. The maximum file size for manual validation is 1.25 MB for manual validation. For instant validation the maximum file size is 0.5 MB.<br />               For security reasons, only the following documents types are accepted: PDF, JPG, JPEG and PNG<br />               Refrain from using TIFF <br /><b>Note:</b> If a previously uploaded document has been rejected, it is possible to upload the same document again to the same document type slot
     * Upload Documents for KYC (Know Your Customers)
     */
    async accountsDocumentsUploadPostRaw(requestParameters: AccountsDocumentsUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadDocumentOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsDocumentsUploadPost.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsDocumentsUploadPost.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsDocumentsUploadPost.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsDocumentsUploadPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountid}/documents/upload`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UploadDocumentInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadDocumentOutputFromJSON(jsonValue));
    }

    /**
     * Upload documents to a payment account. The maximum file size for manual validation is 1.25 MB for manual validation. For instant validation the maximum file size is 0.5 MB.<br />               For security reasons, only the following documents types are accepted: PDF, JPG, JPEG and PNG<br />               Refrain from using TIFF <br /><b>Note:</b> If a previously uploaded document has been rejected, it is possible to upload the same document again to the same document type slot
     * Upload Documents for KYC (Know Your Customers)
     */
    async accountsDocumentsUploadPost(requestParameters: AccountsDocumentsUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadDocumentOutput> {
        const response = await this.accountsDocumentsUploadPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Initialize a Deutsche Post POSTIDENT Identification
     */
    async accountsEnrolmentInitRaw(requestParameters: AccountsEnrolmentInitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EnrolmentInitOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsEnrolmentInit.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsEnrolmentInit.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsEnrolmentInit.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsEnrolmentInit.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountid}/enrolment/init`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EnrolmentInitInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EnrolmentInitOutputFromJSON(jsonValue));
    }

    /**
     * Initialize a Deutsche Post POSTIDENT Identification
     */
    async accountsEnrolmentInit(requestParameters: AccountsEnrolmentInitRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EnrolmentInitOutput> {
        const response = await this.accountsEnrolmentInitRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method enables you get all the Ultimate Beneficial Owners associated to a legal payment account.
     * Get all Ultimate Beneficial Owners associated to a payment account.
     */
    async accountsGetUltimateBeneficialOwnerRaw(requestParameters: AccountsGetUltimateBeneficialOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUltimateBeneficialOwnerOutput>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling accountsGetUltimateBeneficialOwner.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsGetUltimateBeneficialOwner.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsGetUltimateBeneficialOwner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountId}ultimateBeneficialOwner`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUltimateBeneficialOwnerOutputFromJSON(jsonValue));
    }

    /**
     * This method enables you get all the Ultimate Beneficial Owners associated to a legal payment account.
     * Get all Ultimate Beneficial Owners associated to a payment account.
     */
    async accountsGetUltimateBeneficialOwner(requestParameters: AccountsGetUltimateBeneficialOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUltimateBeneficialOwnerOutput> {
        const response = await this.accountsGetUltimateBeneficialOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method allows you to create a individual payment account <br />   1. Your users enter their data on your website, for example on their <b>profile</b> space on your website <br />   2. Your server calls our Accounts API <br />   3. Lemonway creates the payment account in your environment <br />   4. Your system reads the method response and informs the user <br />
     * Create a New Individual Account
     */
    async accountsIndividualPostRaw(requestParameters: AccountsIndividualPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterIndividualAccountOutput>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsIndividualPost.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsIndividualPost.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsIndividualPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/individual`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterIndividualAccountInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegisterIndividualAccountOutputFromJSON(jsonValue));
    }

    /**
     * This method allows you to create a individual payment account <br />   1. Your users enter their data on your website, for example on their <b>profile</b> space on your website <br />   2. Your server calls our Accounts API <br />   3. Lemonway creates the payment account in your environment <br />   4. Your system reads the method response and informs the user <br />
     * Create a New Individual Account
     */
    async accountsIndividualPost(requestParameters: AccountsIndividualPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterIndividualAccountOutput> {
        const response = await this.accountsIndividualPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method enables you to update information related to a client payment account.  1. The user enters their new data  2. The user calls the Lemonway webservice  3. Lemonway records data when it exists  4. The application processes Lemonway\'s response and displays a confirmation message
     * Update Individual Payment Account Data
     */
    async accountsIndividualPutRaw(requestParameters: AccountsIndividualPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateIndividualAccountDetailsOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsIndividualPut.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsIndividualPut.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsIndividualPut.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsIndividualPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/individual/{accountid}`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateIndividualAccountDetailsInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateIndividualAccountDetailsOutputFromJSON(jsonValue));
    }

    /**
     * This method enables you to update information related to a client payment account.  1. The user enters their new data  2. The user calls the Lemonway webservice  3. Lemonway records data when it exists  4. The application processes Lemonway\'s response and displays a confirmation message
     * Update Individual Payment Account Data
     */
    async accountsIndividualPut(requestParameters: AccountsIndividualPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateIndividualAccountDetailsOutput> {
        const response = await this.accountsIndividualPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use this method to find users, documents, IBAN for which the status has changed since a specified date. <br />  Note:<br />  This method will return the same user multiple times in the same request if his status has changed multiple time since a specified date.
     * Find a user, document or an IBAN that has been modified since an entry date
     */
    async accountsKycStatusGetRaw(requestParameters: AccountsKycStatusGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KycStatusOutput>> {
        if (requestParameters.updateDate === null || requestParameters.updateDate === undefined) {
            throw new runtime.RequiredError('updateDate','Required parameter requestParameters.updateDate was null or undefined when calling accountsKycStatusGet.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsKycStatusGet.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsKycStatusGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.updateDate !== undefined) {
            queryParameters['updateDate'] = requestParameters.updateDate;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/kycstatus`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KycStatusOutputFromJSON(jsonValue));
    }

    /**
     * Use this method to find users, documents, IBAN for which the status has changed since a specified date. <br />  Note:<br />  This method will return the same user multiple times in the same request if his status has changed multiple time since a specified date.
     * Find a user, document or an IBAN that has been modified since an entry date
     */
    async accountsKycStatusGet(requestParameters: AccountsKycStatusGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KycStatusOutput> {
        const response = await this.accountsKycStatusGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * The method allows a payment account status to be updated or closed<br />  Note:<br />  The availability of this functionality depends on your contract.
     * Update Payment Account Status
     */
    async accountsKycstatusPutRaw(requestParameters: AccountsKycstatusPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateAccountStatusOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsKycstatusPut.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsKycstatusPut.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsKycstatusPut.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsKycstatusPut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/kycstatus/{accountid}`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateAccountStatusInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateAccountStatusOutputFromJSON(jsonValue));
    }

    /**
     * The method allows a payment account status to be updated or closed<br />  Note:<br />  The availability of this functionality depends on your contract.
     * Update Payment Account Status
     */
    async accountsKycstatusPut(requestParameters: AccountsKycstatusPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateAccountStatusOutput> {
        const response = await this.accountsKycstatusPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method allows you to create a legal payment account <br />   1. Your users enter their data on your website, for example on their <b>profile</b> space on your website <br />   2. Your server calls our Accounts API <br />   3. Lemonway creates the payment account in your environment <br />   4. Your system reads the method response and informs the user <br />
     * Create a New Legal Account
     */
    async accountsLegalPostRaw(requestParameters: AccountsLegalPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RegisterLegalAccountOutput>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsLegalPost.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsLegalPost.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsLegalPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/legal`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterLegalAccountInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegisterLegalAccountOutputFromJSON(jsonValue));
    }

    /**
     * This method allows you to create a legal payment account <br />   1. Your users enter their data on your website, for example on their <b>profile</b> space on your website <br />   2. Your server calls our Accounts API <br />   3. Lemonway creates the payment account in your environment <br />   4. Your system reads the method response and informs the user <br />
     * Create a New Legal Account
     */
    async accountsLegalPost(requestParameters: AccountsLegalPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RegisterLegalAccountOutput> {
        const response = await this.accountsLegalPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method enables you to update information relating to a <b>legal</b> CLIENT payment account.  1. The user enters their new data  2. The user calls the Lemonway webservice  3. Lemonway records data when it exists  4. The application processes Lemonway\'s response and displays a confirmation message
     * Update Legal Payment Account Data
     */
    async accountsLegalSinglePutRaw(requestParameters: AccountsLegalSinglePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateLegalAccountDetailsOutput>> {
        if (requestParameters.accountid === null || requestParameters.accountid === undefined) {
            throw new runtime.RequiredError('accountid','Required parameter requestParameters.accountid was null or undefined when calling accountsLegalSinglePut.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsLegalSinglePut.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsLegalSinglePut.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsLegalSinglePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/legal/{accountid}`.replace(`{${"accountid"}}`, encodeURIComponent(String(requestParameters.accountid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateLegalAccountDetailsInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateLegalAccountDetailsOutputFromJSON(jsonValue));
    }

    /**
     * This method enables you to update information relating to a <b>legal</b> CLIENT payment account.  1. The user enters their new data  2. The user calls the Lemonway webservice  3. Lemonway records data when it exists  4. The application processes Lemonway\'s response and displays a confirmation message
     * Update Legal Payment Account Data
     */
    async accountsLegalSinglePut(requestParameters: AccountsLegalSinglePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateLegalAccountDetailsOutput> {
        const response = await this.accountsLegalSinglePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method enables your system to get detailed payment account information including: payment account balance, account type, if the account is blocked, and account email address.              <br />               Fill at least one search field.
     * Get Detailed Payments Accounts Data
     */
    async accountsRetrievePostRaw(requestParameters: AccountsRetrievePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountDetailsBatchOutput>> {
        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsRetrievePost.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsRetrievePost.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsRetrievePost.');
        }

        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/retrieve`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountDetailsBatchInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountDetailsBatchOutputFromJSON(jsonValue));
    }

    /**
     * This method enables your system to get detailed payment account information including: payment account balance, account type, if the account is blocked, and account email address.              <br />               Fill at least one search field.
     * Get Detailed Payments Accounts Data
     */
    async accountsRetrievePost(requestParameters: AccountsRetrievePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountDetailsBatchOutput> {
        const response = await this.accountsRetrievePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Use the <b>GetWalletTransHistory</b> to retrieve the list of Money-In, Money-Out and P2P (payment between payment account) of a given payment account.  The following numbered list corresponds to the payment type specified in the response attribute <b>Method</b>:  0 Card  1 Bank transfert (MoneyIn)  3 Bank transfert (MoneyOut)  4 P2P  13 IDEAL  14 DirectDebit  15 CHEQUE  16 Neosurf  17 SoFort  18 PFS Physical Card  19 Multibanco  20 Payshop  21 MB WAY  22 Polish Instant Transfer  23 PAGARE  24 MobilePay  25 PayTrail  26 WeChat (via PayTend)  27 P24  28 MoneyIn by TPE  29 Trustly
     * Get list of all Payment Account Transactions
     */
    async accountsTransactionsGetRaw(requestParameters: AccountsTransactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AccountKycStatusOutput>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling accountsTransactionsGet.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsTransactionsGet.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsTransactionsGet.');
        }

        const queryParameters: any = {};

        if (requestParameters.startDate !== undefined) {
            queryParameters['startDate'] = requestParameters.startDate;
        }

        if (requestParameters.endDate !== undefined) {
            queryParameters['endDate'] = requestParameters.endDate;
        }

        if (requestParameters.executionDateStart !== undefined) {
            queryParameters['executionDateStart'] = requestParameters.executionDateStart;
        }

        if (requestParameters.executionDateEnd !== undefined) {
            queryParameters['executionDateEnd'] = requestParameters.executionDateEnd;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountId}/transactions`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountKycStatusOutputFromJSON(jsonValue));
    }

    /**
     * Use the <b>GetWalletTransHistory</b> to retrieve the list of Money-In, Money-Out and P2P (payment between payment account) of a given payment account.  The following numbered list corresponds to the payment type specified in the response attribute <b>Method</b>:  0 Card  1 Bank transfert (MoneyIn)  3 Bank transfert (MoneyOut)  4 P2P  13 IDEAL  14 DirectDebit  15 CHEQUE  16 Neosurf  17 SoFort  18 PFS Physical Card  19 Multibanco  20 Payshop  21 MB WAY  22 Polish Instant Transfer  23 PAGARE  24 MobilePay  25 PayTrail  26 WeChat (via PayTend)  27 P24  28 MoneyIn by TPE  29 Trustly
     * Get list of all Payment Account Transactions
     */
    async accountsTransactionsGet(requestParameters: AccountsTransactionsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AccountKycStatusOutput> {
        const response = await this.accountsTransactionsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This method enables you to update information related to an Ultimate Beneficial Owner.
     * Update Ultimate Beneficial Owner data
     */
    async accountsUpdateUltimateBeneficialOwnerRaw(requestParameters: AccountsUpdateUltimateBeneficialOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UpdateUltimateBeneficialOwnerOutput>> {
        if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
            throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling accountsUpdateUltimateBeneficialOwner.');
        }

        if (requestParameters.ultimateBeneficialOwnerId === null || requestParameters.ultimateBeneficialOwnerId === undefined) {
            throw new runtime.RequiredError('ultimateBeneficialOwnerId','Required parameter requestParameters.ultimateBeneficialOwnerId was null or undefined when calling accountsUpdateUltimateBeneficialOwner.');
        }

        if (requestParameters.authorization === null || requestParameters.authorization === undefined) {
            throw new runtime.RequiredError('authorization','Required parameter requestParameters.authorization was null or undefined when calling accountsUpdateUltimateBeneficialOwner.');
        }

        if (requestParameters.pSUIPAddress === null || requestParameters.pSUIPAddress === undefined) {
            throw new runtime.RequiredError('pSUIPAddress','Required parameter requestParameters.pSUIPAddress was null or undefined when calling accountsUpdateUltimateBeneficialOwner.');
        }

        if (requestParameters.parameters === null || requestParameters.parameters === undefined) {
            throw new runtime.RequiredError('parameters','Required parameter requestParameters.parameters was null or undefined when calling accountsUpdateUltimateBeneficialOwner.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters.authorization !== undefined && requestParameters.authorization !== null) {
            headerParameters['Authorization'] = String(requestParameters.authorization);
        }

        if (requestParameters.pSUAcceptLanguage !== undefined && requestParameters.pSUAcceptLanguage !== null) {
            headerParameters['PSU-Accept-Language'] = String(requestParameters.pSUAcceptLanguage);
        }

        if (requestParameters.pSUIPAddress !== undefined && requestParameters.pSUIPAddress !== null) {
            headerParameters['PSU-IP-Address'] = String(requestParameters.pSUIPAddress);
        }

        if (requestParameters.pSUUserAgent !== undefined && requestParameters.pSUUserAgent !== null) {
            headerParameters['PSU-User-Agent'] = String(requestParameters.pSUUserAgent);
        }

        const response = await this.request({
            path: `/v2/accounts/{accountId}/ultimateBeneficialOwner/{UltimateBeneficialOwnerId}`.replace(`{${"accountId"}}`, encodeURIComponent(String(requestParameters.accountId))).replace(`{${"UltimateBeneficialOwnerId"}}`, encodeURIComponent(String(requestParameters.ultimateBeneficialOwnerId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateUltimateBeneficialOwnerInputToJSON(requestParameters.parameters),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UpdateUltimateBeneficialOwnerOutputFromJSON(jsonValue));
    }

    /**
     * This method enables you to update information related to an Ultimate Beneficial Owner.
     * Update Ultimate Beneficial Owner data
     */
    async accountsUpdateUltimateBeneficialOwner(requestParameters: AccountsUpdateUltimateBeneficialOwnerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UpdateUltimateBeneficialOwnerOutput> {
        const response = await this.accountsUpdateUltimateBeneficialOwnerRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
